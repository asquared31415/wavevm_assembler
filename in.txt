# === sub ===
sub.b r0, r0, r1        # r0 = r0 - r1
sub.b r2, r3, r2        # r2 = r3 - r2
#sub.b r6, r5, r4        # invalid

# === sub_sat ===
sub_sat.b r0, r0, r1    # r0 = r0 - r1
sub_sat.b r2, r3, r2    # r2 = r3 - r2
#sub_sat.b r6, r5, r4    # invalid

# === add ===
add.b r0, r0, r1        # r0 = r0 + r1
add.b r0, r1, r0        # r0 = r1 + r0
#add.b r4, r5, r6        # invalid

# === add_sat ===
add_sat.b r0, r0, r1    # r0 = r0 + r1
add_sat.b r0, r1, r0    # r0 = r1 + r0
#add_sat.b r4, r5, r6    # invalid

# === cmp === #
## == eq == ##
cmpeq.b r0, r0, r1      # r0 = r0 == r1
cmpeq.b r0, r1, r0      # r0 = r1 == r1
#cmpeq.b r4, r5, r6      # invalid

## == ne == ##
cmpneq.b r0, r0, r1      # r0 = r0 != r1
cmpneq.b r0, r1, r0      # r0 = r1 != r0
#cmpneq.b r4, r5, r6      # invalid

UNKNOWN


mov r1.xw, r0.XW # test
store r1.xyzw, [r0.x]+
#comment
load [r0.xyzw], r3.xy
swizzle r2.yxwz
add.w r3, r1
add_sat.b r2, r6
sub.b r6, r5
sub_sat.w r0, r1
subrev.b r1, r0
subrev_sat.b r1, r0
# cmpc.w r0, r1 TODO: re-implement the carry-like things
cmpeq.b r2, r4
cmpneq.w r2, r4

lsl.w r4, 5
asl.b r4, 5 # alias for lsl
rol.b r4, r0
asr.w r4, r0
lsr.w r4, r0
ror.w r4, 5

# maybe implement mov 1, reg and mov 0, reg as bitop w/ zero and one operations?

and r2, r3
or r2, r3
xor r2, r3
nand r2, r3
nor r2, r3
xnor r2, r3
not r3 # notdst
# how to express dst = notsrc?



# test program courtesy of nichepenguin: https://pub.colonq.computer/~nichepenguin/community/community.html#meivm-details
#      x    y    z    w
#c0 0000 A7F4 5ECB 0600 - colormap
#c1 0838 0840 08b8 08c0 - starting address (0800 0808 0880 0888 left)
#c2 0003 0003 0003 0003 - colormap mask (0b11)
#c3 0100 0100 0100 0100 - line address increment (256, two lines of 128x64)
#c4 0001 0000 0000 0000 - 1 | 0 | 0 | 0 (line increment)
#c5 0041 0000 0000 0000 - image data start
#c6 0064 0000 0000 0000 - program start 

# === header code ===

#mov c6.x, r7.x

# === main code ===
# == main loop start ==
swizzle r7.xyzx           # :W restart
mov c1.xyzw, r2.xyzw      # r2 - current draw line addr
mov c5.xyzw, r3.xyzw      # r3 - current image data addr
lsr.w r4, 15              # r4 - clear line counter 
# == line loop start ==
swizzle r7.xyxw           # :Z lines
load [r3.x]+, r0.xyzw     # r0 - image data addres, increment for the next iteration
mov r2.xyzw, r1.xyzw      # r1 - current pixel target address
# == pixel loop start ==
swizzle r7.xxzw           # :Y pixels
mov r0.xyzw, r5.xyzw      # r5 - pixel data
and c2, r5                # apply mask - get color indexes
load [r5.xyzw], r6.xyzw   # r6 - color data [freeing r5]
store r6.xyzw, [r1.xyzw]+    # draw and increment pixel target address [freeing r6]
rol.w r0, 2               # roll image data to the next pixel
# linebreak test
mov r1.xyzw, r6.xyzw      # r6 - test result
subrev.w r6, r2           # subtract line start address from current pixel address
lsr.w r6, 3               # right-shift counter (1000 -> 0001, other -> 0000)
mov c4.yzw, r6.yzw        # zero-out yzw of a jump increment
add.w r6, r7              # jump over if test is true [freeing r6]
swizzle r7.yyzw           # jump to :Y => next pixel
# == pixel loop end ==
add.w c3, r2              # increment line addr 
add.w c4, r4              # increment line counter
# restart test
mov r4.xyzw, r6.xyzw      # r6 - test result
lsr.w r6, 3               # right-shift counter to get the jump (1000 -> 0001, other -> 0000)
add.w r6, r7              # jump over if test is true [freeing r6]
swizzle r7.zyzw           # jump to :Z => next line
# == line loop end ==
swizzle r7.wyzw           # jump to :W => restart
# == main loop end
